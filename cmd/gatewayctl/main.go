package main

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/mylxsw/openai-cost-optimal-gateway/internal/config"
	"github.com/mylxsw/openai-cost-optimal-gateway/internal/gateway"
)

const defaultConfigDescription = "# Generated by gatewayctl init\n# Update access tokens and provider endpoints before using in production.\n"

func main() {
	if err := run(os.Args[1:]); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run(args []string) error {
	if len(args) == 0 {
		printUsage()
		return errors.New("no command specified")
	}

	switch args[0] {
	case "init":
		return runInit(args[1:])
	case "preview":
		return runPreview(args[1:])
	case "add-provider":
		return runAddProvider(args[1:])
	case "add-model":
		return runAddModel(args[1:])
	case "help", "-h", "--help":
		printUsage()
		return nil
	default:
		printUsage()
		return fmt.Errorf("unknown command %q", args[0])
	}
}

func printUsage() {
	fmt.Println(`Usage: gatewayctl <command> [options]

Commands:
  init           Generate a starter configuration file
  preview        Validate and preview routing behavior from a configuration
  add-provider   Append a provider definition to an existing configuration
  add-model      Append a logical model to an existing configuration

Use "gatewayctl <command> --help" to see command-specific options.`)
}

func runInit(args []string) error {
	fs := flag.NewFlagSet("init", flag.ContinueOnError)
	output := fs.String("output", "", "write configuration to the given file instead of stdout")
	force := fs.Bool("force", false, "overwrite the output file if it already exists")
	if err := fs.Parse(args); err != nil {
		return err
	}

	cfg := &config.Config{
		Listen:  "0.0.0.0:8000",
		Debug:   false,
		Default: "openai-official",
		APIKeys: []string{"sk-your-gateway-key"},
		Providers: []config.ProviderConfig{{
			ID:          "openai-official",
			Type:        config.ProviderTypeOpenAI,
			BaseURL:     "https://api.openai.com/v1",
			AccessToken: "sk-your-openai-access-token",
		}},
		Models: []config.ModelConfig{{
			Name: "gpt-4o-mini",
			Providers: config.ModelProviders{
				{ID: "openai-official"},
			},
		}},
	}

	rendered, err := marshalConfig(cfg)
	if err != nil {
		return err
	}

	if *output == "" {
		fmt.Print(defaultConfigDescription)
		fmt.Print(rendered)
		return nil
	}

	if !*force {
		if _, err := os.Stat(*output); err == nil {
			return fmt.Errorf("file %s already exists (use --force to overwrite)", *output)
		} else if !os.IsNotExist(err) {
			return fmt.Errorf("check output path: %w", err)
		}
	}

	if err := os.WriteFile(*output, []byte(defaultConfigDescription+rendered), 0o644); err != nil {
		return fmt.Errorf("write configuration: %w", err)
	}

	fmt.Printf("Configuration written to %s\n", *output)
	return nil
}

func runPreview(args []string) error {
	fs := flag.NewFlagSet("preview", flag.ContinueOnError)
	confPath := fs.String("conf", "config.yaml", "path to the configuration file")
	if err := fs.Parse(args); err != nil {
		return err
	}

	cfg, err := config.Load(*confPath)
	if err != nil {
		return err
	}

	if _, err := gateway.New(cfg, nil); err != nil {
		return err
	}

	fmt.Printf("Configuration %s is valid.\n\n", *confPath)
	fmt.Printf("Listen: %s\n", cfg.Listen)
	fmt.Printf("Debug logging: %v\n", cfg.Debug)
	if cfg.Default != "" {
		fmt.Printf("Default provider fallback: %s\n", cfg.Default)
	} else {
		fmt.Printf("Default provider fallback: <disabled>\n")
	}
	fmt.Printf("Gateway API keys: %d configured\n", len(cfg.APIKeys))

	fmt.Println("\nProviders:")
	providers := append([]config.ProviderConfig(nil), cfg.Providers...)
	sort.Slice(providers, func(i, j int) bool { return providers[i].ID < providers[j].ID })
	for _, p := range providers {
		fmt.Printf("- %s (%s)\n", p.ID, providerTypeLabel(p.Type))
		fmt.Printf("    Base URL : %s\n", p.BaseURL)
		if p.Timeout > 0 {
			fmt.Printf("    Timeout  : %s\n", p.Timeout)
		}
		if len(p.Headers) > 0 {
			keys := make([]string, 0, len(p.Headers))
			for k := range p.Headers {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			fmt.Printf("    Headers  :\n")
			for _, k := range keys {
				fmt.Printf("        %s: %s\n", k, p.Headers[k])
			}
		}
	}

	fmt.Println("\nModels:")
	if len(cfg.Models) == 0 {
		fmt.Println("  <none>")
		return nil
	}

	for _, m := range cfg.Models {
		fmt.Printf("- %s\n", m.Name)
		if len(m.Providers) == 0 {
			fmt.Println("    Providers: <none>")
		} else {
			fmt.Println("    Default routing order:")
			for idx, provider := range m.Providers {
				fmt.Printf("      %d. %s", idx+1, provider.ID)
				if provider.Model != "" {
					fmt.Printf(" (as %s)", provider.Model)
				}
				fmt.Println()
			}
		}
		if len(m.Rules) == 0 {
			fmt.Println("    Rules: <none>")
			continue
		}
		fmt.Println("    Rules:")
		for _, rule := range m.Rules {
			fmt.Printf("      - when %s\n", rule.Expression)
			for _, override := range rule.Providers {
				fmt.Printf("          -> %s", override.Provider)
				if override.Model != "" {
					fmt.Printf(" (as %s)", override.Model)
				}
				fmt.Println()
			}
		}
	}

	return nil
}

func runAddProvider(args []string) error {
	fs := flag.NewFlagSet("add-provider", flag.ContinueOnError)
	confPath := fs.String("conf", "config.yaml", "path to the configuration file")
	apply := fs.Bool("apply", false, "write the updated configuration back to the file")
	id := fs.String("id", "", "unique provider identifier")
	providerType := fs.String("type", string(config.ProviderTypeOpenAI), "provider type (openai, anthropic, ...)")
	baseURL := fs.String("base_url", "", "provider base URL")
	accessToken := fs.String("access_token", "", "provider access token")
	timeoutStr := fs.String("timeout", "", "optional request timeout, e.g. 30s")
	headers := keyValueFlag{}
	fs.Var(&headers, "header", "custom header in KEY=VALUE format (can be repeated)")

	if err := fs.Parse(args); err != nil {
		return err
	}
	if *id == "" {
		return errors.New("--id is required")
	}
	if *baseURL == "" {
		return errors.New("--base_url is required")
	}
	if *accessToken == "" {
		return errors.New("--access_token is required")
	}

	cfg, err := config.Load(*confPath)
	if err != nil {
		return err
	}

	if existing, ok := cfg.ProviderByID(*id); ok {
		return fmt.Errorf("provider %s already exists with base URL %s", *id, existing.BaseURL)
	}

	provider := config.ProviderConfig{
		ID:          *id,
		Type:        config.ProviderType(*providerType),
		BaseURL:     *baseURL,
		AccessToken: *accessToken,
		Headers:     headers.Values,
	}

	if *timeoutStr != "" {
		duration, err := time.ParseDuration(*timeoutStr)
		if err != nil {
			return fmt.Errorf("parse timeout: %w", err)
		}
		provider.Timeout = duration
	}

	cfg.Providers = append(cfg.Providers, provider)

	if err := cfg.Validate(); err != nil {
		return err
	}

	return outputConfig(cfg, *confPath, *apply)
}

func runAddModel(args []string) error {
	fs := flag.NewFlagSet("add-model", flag.ContinueOnError)
	confPath := fs.String("conf", "config.yaml", "path to the configuration file")
	apply := fs.Bool("apply", false, "write the updated configuration back to the file")
	name := fs.String("name", "", "model name exposed by the gateway")
	providerFlags := stringSliceFlag{}
	fs.Var(&providerFlags, "provider", "provider routing entry in the form provider[:upstream-model] (repeatable)")

	if err := fs.Parse(args); err != nil {
		return err
	}

	if *name == "" {
		return errors.New("--name is required")
	}
	if len(providerFlags.Values) == 0 {
		return errors.New("at least one --provider must be specified")
	}

	cfg, err := config.Load(*confPath)
	if err != nil {
		return err
	}

	for _, existing := range cfg.Models {
		if existing.Name == *name {
			return fmt.Errorf("model %s already exists", *name)
		}
	}

	providers := make(config.ModelProviders, 0, len(providerFlags.Values))
	for _, entry := range providerFlags.Values {
		id := entry
		upstreamModel := ""
		if idx := strings.Index(entry, ":"); idx >= 0 {
			id = entry[:idx]
			upstreamModel = entry[idx+1:]
		}
		if id == "" {
			return fmt.Errorf("invalid provider spec %q", entry)
		}
		if _, ok := cfg.ProviderByID(id); !ok {
			return fmt.Errorf("unknown provider %s", id)
		}
		providers = append(providers, config.ModelProvider{ID: id, Model: upstreamModel})
	}

	cfg.Models = append(cfg.Models, config.ModelConfig{
		Name:      *name,
		Providers: providers,
	})

	if err := cfg.Validate(); err != nil {
		return err
	}

	return outputConfig(cfg, *confPath, *apply)
}

func outputConfig(cfg *config.Config, path string, apply bool) error {
	rendered, err := marshalConfig(cfg)
	if err != nil {
		return err
	}

	if !apply {
		fmt.Print(rendered)
		return nil
	}

	if err := os.WriteFile(path, []byte(rendered), 0o644); err != nil {
		return fmt.Errorf("write configuration: %w", err)
	}
	fmt.Printf("Configuration updated at %s\n", path)
	return nil
}

func marshalConfig(cfg *config.Config) (string, error) {
	var b strings.Builder

	writeLine(&b, "listen: %s", quoteString(cfg.Listen))
	writeLine(&b, "debug: %t", cfg.Debug)
	if cfg.Default != "" {
		writeLine(&b, "default-provider: %s", quoteString(cfg.Default))
	}

	b.WriteString("\n")
	if len(cfg.APIKeys) == 0 {
		writeLine(&b, "api_keys: []")
	} else {
		writeLine(&b, "api_keys:")
		for _, key := range cfg.APIKeys {
			writeLine(&b, "  - %s", quoteString(key))
		}
	}

	b.WriteString("\n")
	if len(cfg.Providers) == 0 {
		writeLine(&b, "providers: []")
	} else {
		writeLine(&b, "providers:")
		for _, provider := range cfg.Providers {
			writeLine(&b, "  - id: %s", quoteString(provider.ID))
			if provider.Type != "" {
				writeLine(&b, "    type: %s", quoteString(string(provider.Type)))
			}
			writeLine(&b, "    base_url: %s", quoteString(provider.BaseURL))
			writeLine(&b, "    access_token: %s", quoteString(provider.AccessToken))
			if provider.Timeout > 0 {
				writeLine(&b, "    timeout: %s", quoteString(provider.Timeout.String()))
			}
			if len(provider.Headers) > 0 {
				keys := make([]string, 0, len(provider.Headers))
				for k := range provider.Headers {
					keys = append(keys, k)
				}
				sort.Strings(keys)
				writeLine(&b, "    headers:")
				for _, key := range keys {
					writeLine(&b, "      %s: %s", quoteString(key), quoteString(provider.Headers[key]))
				}
			}
		}
	}

	b.WriteString("\n")
	if len(cfg.Models) == 0 {
		writeLine(&b, "models: []")
	} else {
		writeLine(&b, "models:")
		for _, model := range cfg.Models {
			writeLine(&b, "  - model: %s", quoteString(model.Name))
			if len(model.Providers) == 0 {
				writeLine(&b, "    providers: []")
			} else {
				writeLine(&b, "    providers:")
				for _, provider := range model.Providers {
					writeLine(&b, "      - provider: %s", quoteString(provider.ID))
					if provider.Model != "" {
						writeLine(&b, "        model: %s", quoteString(provider.Model))
					}
				}
			}
			if len(model.Rules) > 0 {
				writeLine(&b, "    rules:")
				for _, rule := range model.Rules {
					writeLine(&b, "      - rule: %s", quoteString(rule.Expression))
					if len(rule.Providers) > 0 {
						writeLine(&b, "        providers:")
						for _, override := range rule.Providers {
							writeLine(&b, "          - provider: %s", quoteString(override.Provider))
							if override.Model != "" {
								writeLine(&b, "            model: %s", quoteString(override.Model))
							}
						}
					} else {
						writeLine(&b, "        providers: []")
					}
				}
			}
		}
	}

	return b.String(), nil
}

func providerTypeLabel(t config.ProviderType) string {
	if t == "" {
		return "openai"
	}
	return string(t)
}

func writeLine(b *strings.Builder, format string, args ...interface{}) {
	fmt.Fprintf(b, format+"\n", args...)
}

func quoteString(val string) string {
	if val == "" {
		return "\"\""
	}
	return strconv.Quote(val)
}

type keyValueFlag struct {
	Values map[string]string
}

func (k *keyValueFlag) String() string {
	if len(k.Values) == 0 {
		return ""
	}
	parts := make([]string, 0, len(k.Values))
	for key, val := range k.Values {
		parts = append(parts, fmt.Sprintf("%s=%s", key, val))
	}
	sort.Strings(parts)
	return strings.Join(parts, ", ")
}

func (k *keyValueFlag) Set(value string) error {
	if k.Values == nil {
		k.Values = make(map[string]string)
	}
	idx := strings.Index(value, "=")
	if idx <= 0 {
		return fmt.Errorf("invalid header %q, expected KEY=VALUE", value)
	}
	key := strings.TrimSpace(value[:idx])
	val := strings.TrimSpace(value[idx+1:])
	if key == "" {
		return fmt.Errorf("header key cannot be empty")
	}
	k.Values[key] = val
	return nil
}

type stringSliceFlag struct {
	Values []string
}

func (s *stringSliceFlag) String() string {
	return strings.Join(s.Values, ",")
}

func (s *stringSliceFlag) Set(value string) error {
	s.Values = append(s.Values, value)
	return nil
}
